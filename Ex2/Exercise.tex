%% ================================================================
%% # DBIS Databases Hand-in Template
%% 
%% Template for students to hand-in their databases exercise solutions.
%% 
%% [Databases and Information Systems Group](https://dbis.dmi.unibas.ch/)
%%
%% ## Usage
%% 
%% Fill in the required fields and write your submission
%%
%% ## Issues
%%
%% See dbisdbhandin.sty for further information.
%% ================================================================
\documentclass{article}
\usepackage{dbisdbhandin}
\usepackage[english]{babel}
%% ================================================================
%%
%% General Information
%%
%% ================================================================
%%
%% Add your information here
\course       {Databases}
\semester     {Autumn 2025}
\exerciseno   {1}
\studenta     {Aiysha Frutiger}
\studentb     {Jannick Seper}
\studentc     {Luis Tritschler}
%% Comment if you do the exercises alone


%% ================================================================
%%
%% Common Packages
%%
%% ================================================================
%%
%% Useful common packages for this course

%% Include pdfs into latex
\usepackage{pdfpages}
%% \includepdf[pages=1,pagecommand={\pagestyle{fancy}}]{filename}

%% Drawing everything, with lots of libraries
\usepackage{tikz}
%% A library providing ER prefabs
\usetikzlibrary{er}
\usetikzlibrary{positioning,arrows.meta}


\usepackage{enumitem}
% show subtask labels as "<current task number><letter>" e.g., 2a, 2b
\newlist{subtasks}{enumerate}{1}
\setlist[subtasks]{label=\arabic{task}\alph*), ref=\arabic{task}\alph*)}

%% ================================================================
%%
%% Custom Packages
%%
%% ================================================================
%%
%% Add custom packages below:
%%

% \usepackage{mypackage}

%% ================================================================
%%
%% Custom Commands
%%
%% ================================================================
%%
%% DRY: Use commands when you use something often or you'd like
%% to define it only once
%%

\newcommand*{\TikZ}{Ti\textit{k}Z}


\begin{document}

\printfront

% ---------------- Task 1 ----------------

\task{}
Given excerpt of the relational schema plus added relations and integrety constrain befor the first bullet point.
\lstinputlisting[language=SQL,frame=single,numbers=left,numberstyle=\tiny]{task1_givennew.sql}
\newpage
\begin{itemize}
    \item 
    \textit{The title of the lecture has to be unique and may not be altered if any exercise is
    available for the lecture.}\\
    The first part of the point is already enforced bc the title of the lecture is a \texttt{PRIMARY KEY} and therefore must be unique. The second part can be enforced with this addition.
    \lstinputlisting[language=SQL,frame=single,numbers=left,numberstyle=\tiny]{task1_1.sql}
    \item 
    \textit{For a lecture, no more than 10 credit points may be awarded.}\\
    This part can be enforced with this assertion.
    \lstinputlisting[language=SQL,frame=single,numbers=left,numberstyle=\tiny]{task1_2.sql}
    \item 
    \textit{Lecturers may give multiple lectures.}\\
    This part is beeing enforced with this.
    \lstinputlisting[language=SQL,frame=single,numbers=left,numberstyle=\tiny]{task1_3.sql}
    \item 
    \textit{A lecture may include several exercises. An exercise always belongs to exactly one
    lecture.}\\
    The first part is already enforced via the foreign key while for the second part we have to add the \texttt{NOT NULL} so we guaratee that e exersise must be in one lecture.
    \lstinputlisting[language=SQL,frame=single,numbers=left,numberstyle=\tiny]{task1_4.sql}
    \item 
    \textit{Before a new author is entered into the system, it should be checked that no other
    author with the same first name, last name and title is present.}\\
    This part is beeing enforced with this.
    \lstinputlisting[language=SQL,frame=single,numbers=left,numberstyle=\tiny]{task1_5.sql}

\end{itemize}


% ---------------- Task 2 ----------------
\task{Foreign Keys}

\begin{subtasks}

\item % -> prints "2a)"
\textbf{Foreign Keys}\\
For the relation \texttt{Lecture}, the following foreign key is defined in SQL:
\begin{lstlisting}[language=SQL,frame=single,numbers=left,numberstyle=\tiny]
CREATE TABLE Lecture (
  ...,
  FOREIGN KEY (fk_lecturer) REFERENCES Lecturer(pk_lecturer)
);
\end{lstlisting}

In the following, this foreign key is simulated using \emph{(i)} an assertion and \emph{(ii)} triggers.

\begin{enumerate}[label=(\roman*)]
\item \textbf{Assertion (static integrity constraint)}\\
An \texttt{ASSERTION} ensures that no tuple in \texttt{Lecture} references a non-existent \texttt{Lecturer}.
We formulate this as a double \texttt{NOT EXISTS} statement that expresses the same semantics as a foreign key.

\begin{lstlisting}[language=SQL,frame=single,numbers=left,numberstyle=\tiny]
CREATE ASSERTION FK_Lecture_Lecturer_OK
CHECK (
  NOT EXISTS (
    SELECT 1
    FROM Lecture L
    WHERE L.fk_lecturer IS NOT NULL
      AND NOT EXISTS (
        SELECT 1
        FROM Lecturer R
        WHERE R.pk_lecturer = L.fk_lecturer
      )
  )
)
DEFERRABLE INITIALLY IMMEDIATE;
\end{lstlisting}

This assertion guarantees that for every non-NULL value in \texttt{Lecture.fk\_lecturer}, a matching \texttt{Lecturer.pk\_lecturer} exists. The condition is checked globally and can be deferred to commit time using the \texttt{DEFERRABLE} clause.

\item \textbf{Triggers (dynamic integrity constraint)}\\
The same referential integrity can be dynamically enforced by triggers (E–C–A pattern):
\begin{itemize}
  \item \textbf{Child-side:} Prevent inserting or updating a \texttt{Lecture} with a non-existent \texttt{fk\_lecturer}.
  \item \textbf{Parent-side:} Prevent deleting or updating a \texttt{Lecturer} that is still referenced by a \texttt{Lecture}.
\end{itemize}

\paragraph{Child-side triggers (on \texttt{Lecture})}
\begin{lstlisting}[language=SQL,frame=single,numbers=left,numberstyle=\tiny]
CREATE TRIGGER Lecture_FK_Check_Ins 
BEFORE INSERT ON Lecture 
WHEN (NEW.fk_lecturer IS NOT NULL AND
      NOT EXISTS (SELECT 1 FROM Lecturer R 
                  WHERE R.pk_lecturer = NEW.fk_lecturer))
( ROLLBACK WORK );

CREATE TRIGGER Lecture_FK_Check_Upd 
BEFORE UPDATE OF fk_lecturer ON Lecture
REFERENCING NEW AS Lnew
WHEN (Lnew.fk_lecturer IS NOT NULL AND 
      NOT EXISTS (SELECT 1 FROM Lecturer R
                  WHERE R.pk_lecturer = Lnew.fk_lecturer))
( ROLLBACK WORK );
\end{lstlisting}

\paragraph{Parent-side triggers (on \texttt{Lecturer})}
\begin{lstlisting}[language=SQL,frame=single,numbers=left,numberstyle=\tiny]
CREATE TRIGGER Lecturer_Ref_Block_Del
BEFORE DELETE ON Lecturer
REFERENCING OLD AS Pold
WHEN (EXISTS (SELECT 1 FROM Lecture L
              WHERE L.fk_lecturer = Pold.pk_lecturer))
( ROLLBACK WORK );

CREATE TRIGGER Lecturer_Ref_Block_Upd
BEFORE UPDATE OF pk_lecturer ON Lecturer
REFERENCING OLD AS Pold NEW AS Pnew
WHEN (EXISTS (SELECT 1 FROM Lecture L
              WHERE L.fk_lecturer = Pold.pk_lecturer))
( ROLLBACK WORK );
\end{lstlisting}

\begin{itemize}
  \item The \textbf{child-side} triggers prevent inserting or updating a lecture referencing a non-existent lecturer.
  \item The \textbf{parent-side} triggers prevent deleting or changing a lecturer ID if at least one lecture still refers to it.
  \item The \texttt{ROLLBACK WORK} aborts the transaction on violation (\texttt{NO ACTION}-like).
\end{itemize}
\end{enumerate} % <-- end (i)/(ii) list inside 2a

\item % -> prints "2b)"
\textbf{Simulating \texttt{FOREIGN KEY (FkExam) REFERENCES Exam(PkExam) ON DELETE SET NULL} with triggers}

We enforce referential integrity procedurally:
\begin{itemize}
  \item \textbf{Child-side (Student).} Block \texttt{INSERT}/\texttt{UPDATE} that sets \texttt{FkExam} to a non-existent \texttt{Exam.PkExam} (allow \texttt{NULL}).
  \item \textbf{Parent-side (Exam) on \texttt{DELETE}.} Before deleting an \texttt{Exam} row, set \texttt{Student.FkExam := NULL} for all referencing students (\texttt{ON DELETE SET NULL}).
  \item \textbf{Parent-side (Exam) on \texttt{UPDATE PkExam}.} Default is \emph{NO ACTION}; block if referenced.
\end{itemize}

\paragraph{Child-side checks (INSERT/UPDATE on \texttt{Student})}
\begin{lstlisting}[language=SQL,frame=single,numbers=left,numberstyle=\tiny]
CREATE TRIGGER Student_FK_Check_Ins
BEFORE INSERT ON Student
WHEN ( NEW.FkExam IS NOT NULL AND
       NOT EXISTS (SELECT 1 FROM Exam E
                   WHERE E.PkExam = NEW.FkExam) )
( ROLLBACK WORK );

CREATE TRIGGER Student_FK_Check_Upd
BEFORE UPDATE OF FkExam ON Student
REFERENCING NEW AS Snew
WHEN ( Snew.FkExam IS NOT NULL AND
       NOT EXISTS (SELECT 1 FROM Exam E
                   WHERE E.PkExam = Snew.FkExam) )
( ROLLBACK WORK );
\end{lstlisting}

\paragraph{Parent-side action (DELETE on \texttt{Exam}) — simulate \texttt{ON DELETE SET NULL}}
\begin{lstlisting}[language=SQL,frame=single,numbers=left,numberstyle=\tiny]
CREATE TRIGGER Exam_Delete_SetNull
BEFORE DELETE ON Exam
REFERENCING OLD AS Eold
(
  UPDATE Student
  SET FkExam = NULL
  WHERE FkExam = Eold.PkExam
);
\end{lstlisting}

\paragraph{Parent-side block (UPDATE of \texttt{PkExam}) — simulate \texttt{ON UPDATE NO ACTION}}
\begin{lstlisting}[language=SQL,frame=single,numbers=left,numberstyle=\tiny]
CREATE TRIGGER Exam_Block_Update_PK
BEFORE UPDATE OF PkExam ON Exam
REFERENCING OLD AS Eold NEW AS Enew
WHEN ( EXISTS (SELECT 1 FROM Student S
               WHERE S.FkExam = Eold.PkExam) )
( ROLLBACK WORK );
\end{lstlisting}

\textit{Notes.}
\begin{itemize}
  \item Ensure \texttt{Student(FkExam)} allows \texttt{NULL}; otherwise \texttt{SET NULL} would fail.
  \item The \texttt{DELETE} trigger clears references before parent removal.
  \item Using \texttt{ROLLBACK WORK} follows the lecture’s “block on violation” pattern.
\end{itemize}

\end{subtasks}
% -------------- end Task 2 --------------


\task{}

\task{}
When we say something is \textbf{DEFERRABLE INITIALLY DEFERRED}, it means that the database will wait until the end of a transaction before checking certain rules, such as foreign key constraints. This is useful when two tables depend on each other. For example, a \texttt{Lecture} table and a \texttt{Lecturer} table. A lecture record might point to the lecturer who gives it, while the lecturer record might also depend on the lecture. If we try to insert both of these in the same transaction, the database might raise an error because when we insert the first one, the other does not yet exist.


If the rule is \textbf{NOT DEFERRABLE}, the database checks immediately, and the operation fails. If it is \textbf{DEFERRABLE INITIALLY IMMEDIATE}, we would need to manually tell the database to delay the check. However, if it is \textbf{DEFERRABLE INITIALLY DEFERRED}, the database automatically waits until the transaction ends to perform the checks. This allows both inserts to complete first, and the database only verifies the rules afterward, which helps prevent errors.


\end{document}


\end{document}
