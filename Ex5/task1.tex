

We are given the relations
\[
U(a,b,c),\quad V(c,d,e),\quad W(e,f,g)
\]
and the following SQL query:
\begin{verbatim}
SELECT b, f
FROM (
  SELECT V.c, V.d, W.e, W.f, W.g
  FROM V, W
  WHERE V.e = W.e
    AND f = 2
    AND g = 10
) 
JOIN U ON U.c = V.c
WHERE a LIKE 'Ben';
\end{verbatim}

\setcounter{subtask}{0}

\subtask{Relational algebra and algebraic operator tree}

A translation of the query into relational algebra is:
\[
\pi_{b,f}\Bigl(
  \sigma_{a \,\text{LIKE}\, 'Ben'}\bigl(
    \bigl(
      \pi_{V.c,\,V.d,\,W.e,\,W.f,\,W.g}\bigl(
        \sigma_{V.e = W.e \,\land\, W.f = 2 \,\land\, W.g = 10}
        (\,V \times W\,)
      \bigr)
    \bigr)
    \Join_{U.c = V.c}
    U
  \bigr)
\Bigr).
\]


The corresponding algebraic operator tree is shown in
Figure~\ref{fig:op-tree}.

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[nodes={draw, circle}, node distance=4em]
    % Root: projection π_{b,f}
    \node (pi1) {$\pi$};
    \node[right=0.5em of pi1, draw=none] {$b, f$};

    % Selection σ_{a LIKE 'Ben'}
    \node[below of=pi1] (sigma1) {$\sigma$} edge (pi1);
    \node[right=0.5em of sigma1, draw=none] {$a \text{ LIKE 'Ben'}$};

    % Join ⨝_{U.c = V.c}
    \node[below of=sigma1] (join1) {$\Join$} edge (sigma1);
    \node[right=0.5em of join1, draw=none] {$U.c = V.c$};

    % Left child of join1: relation U
    \node[below left of=join1] (U) {U} edge (join1);

    % Right child of join1: subtree (inner SELECT)
    \node[below right of=join1] (pi2) {$\pi$} edge (join1);
    \node[right=0.5em of pi2, draw=none] {$V.c, V.d, W.e, W.f, W.g$};

    % σ_{V.e = W.e ∧ W.f = 2 ∧ W.g = 10}
    \node[below of=pi2] (sigma2) {$\sigma$} edge (pi2);
    \node[right=0.5em of sigma2, draw=none] {$V.e = W.e \land W.f = 2 \land W.g = 10$};

    % × with children V and W
    \node[below of=sigma2] (prod) {$\times$} edge (sigma2);
    \node[below left of=prod] (V) {V} edge (prod);
    \node[below right of=prod] (W) {W} edge (prod);
  \end{tikzpicture}
  \caption{Algebraic operator tree for the given SQL query.}
  \label{fig:op-tree}
\end{figure}


\newpage

\subtask{Query optimizer}


We transform the canonical algebraic expression step by step using
equivalence rules of the relational algebra. The goal is to push
selections and projections as far down as possible and to replace
Cartesian products plus join conditions by joins, in order to reduce
the size of intermediate results.

Rule 10 – Split selection with conjunction

\[
\sigma_{P_1 \land P_2 \land P_3}(R)
=
\sigma_{P_1}\bigl(
  \sigma_{P_2}\bigl(
    \sigma_{P_3}(R)
  \bigr)
\bigr).
\]

This rule is used to turn the single selection
\[
\sigma_{V.e = W.e \,\land\, W.f = 2 \,\land\, W.g = 10}(V \times W)
\]
into a cascade of three selections, so that the conditions can later
be pushed down independently.

Rule 15 – Swap selection and Cartesian product

\[
\sigma_{P}(R \times S)
=
\sigma_{P}(R) \times S
\quad\text{if $P$ uses only attributes of $R$.}
\]

This rule is used to push the selections
\(\sigma_{W.f = 2}\) and \(\sigma_{W.g = 10}\) from
\(\sigma_{W.f = 2}(\sigma_{W.g = 10}(V \times W))\)
down onto \(W\), since both conditions refer only to attributes of \(W\).

Rule 22 – Combine selection and product into join

\[
\sigma_{R.A = S.B}(R \times S)
=
R \Join_{R.A = S.B} S.
\]

This rule is used to replace
\[
\sigma_{V.e = W.e}\bigl(V \times W'\bigr)
\]
by the join
\[
V \Join_{V.e = W.e} W',
\]
where \(W' = \sigma_{W.f = 2}(\sigma_{W.g = 10}(W))\). This eliminates
the large Cartesian product in favor of a join with already filtered
\(W\).

Rule 14 – Swap selection and join

\[
\sigma_{P}(R \Join S)
=
\sigma_{P}(R) \Join S
\quad\text{if $P$ uses only attributes of $R$.}
\]

This rule is used to pull the selection
\(\sigma_{a \text{ LIKE 'Ben'}}\) down onto \(U\) in
\[
\sigma_{a \text{ LIKE 'Ben'}}\bigl(R \Join_{U.c = V.c} U\bigr)
\;\equiv\;
R \Join_{U.c = V.c} \sigma_{a \text{ LIKE 'Ben'}}(U),
\]
since the predicate involves only attribute \(a\) of relation \(U\).

Rule 16 – Swap projection and join (projection push-down)

\[
\pi_{Q}(R \Join_{P} S)
=
\pi_{Q}\bigl(
  \pi_{Q_1}(R) \Join_{P} \pi_{Q_2}(S)
\bigr),
\]
where \(Q_1\) and \(Q_2\) contain the attributes from \(Q\) and from the
join predicate \(P\) that belong to each side.

This rule is used to introduce projections on \(U\), \(V\), and \(W\) so
that each relation only carries the attributes that are actually needed:

\begin{itemize}
  \item result attributes: \(b\) (from \(U\)) and \(f\) (from \(W\)),
  \item join attributes: \(c\) on \(U\) and \(V\), \(e\) on \(V\) and \(W\),
  \item selection attributes: \(a\) on \(U\); \(f\) and \(g\) on \(W\).
\end{itemize}

Thus we choose the minimal attribute sets
\[
U: \{a, b, c\}, \quad
V: \{c, e\}, \quad
W: \{e, f, g\},
\]
and obtain the optimized algebraic expression
\[
Q_{\text{opt}} =
\pi_{b,f} \Bigl(
  \bigl(
    \pi_{c,e}(V)
    \Join_{V.e = W.e}
    \sigma_{W.f = 2 \,\land\, W.g = 10}
    \bigl(\pi_{e,f,g}(W)\bigr)
  \bigr)
  \Join_{U.c = V.c}
  \sigma_{a \text{ LIKE 'Ben'}}
  \bigl(\pi_{a,b,c}(U)\bigr)
\Bigr).
\]

In this form, all selections and projections are pushed down to the
leaves, the Cartesian product is replaced by joins, and intermediate
results are reduced.

\medskip

The corresponding optimized operator tree is:

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[nodes={draw, circle}, node distance=4em]
    % Root: π_{b,f}
    \node (pi_root) {$\pi$};
    \node[right=0.5em of pi_root, draw=none] {$b, f$};

    % Join U with the (V⋈W) part
    \node[below of=pi_root] (join_uv) {$\Join$} edge (pi_root);
    \node[right=0.5em of join_uv, draw=none] {$U.c = V.c$};

    % Left branch: σ_{a LIKE 'Ben'}(π_{a,b,c}(U))
    \node[below left of=join_uv] (pi_u) {$\pi$} edge (join_uv);
    \node[right=0.5em of pi_u, draw=none] {$a, b, c$};

    \node[below of=pi_u] (sigma_u) {$\sigma$} edge (pi_u);
    \node[right=0.5em of sigma_u, draw=none] {$a \text{ LIKE 'Ben'}$};

    \node[below of=sigma_u] (U) {U} edge (sigma_u);

    % Right branch: (π_{c,e}(V)) ⋈ (σ_{f=2 ∧ g=10}(π_{e,f,g}(W)))
    \node[below right of=join_uv] (join_vw) {$\Join$} edge (join_uv);
    \node[right=0.5em of join_vw, draw=none] {$V.e = W.e$};

    % Left child of join_vw: π_{c,e}(V)
    \node[below left of=join_vw] (pi_v) {$\pi$} edge (join_vw);
    \node[right=0.5em of pi_v, draw=none] {$c, e$};

    \node[below of=pi_v] (V) {V} edge (pi_v);

    % Right child of join_vw: σ_{f=2 ∧ g=10}(π_{e,f,g}(W))
    \node[below right of=join_vw] (sigma_w) {$\sigma$} edge (join_vw);
    \node[right=0.5em of sigma_w, draw=none] {$f = 2 \land g = 10$};

    \node[below of=sigma_w] (pi_w) {$\pi$} edge (sigma_w);
    \node[right=0.5em of pi_w, draw=none] {$e, f, g$};

    \node[below of=pi_w] (W) {W} edge (pi_w);
  \end{tikzpicture}
  \caption{Optimized algebraic operator tree for the given SQL query.}
  \label{fig:op-tree-optimized}
\end{figure}



\newpage

\subtask{Cardinality estimation}

We assume that the attributes $a$, $f$ and $g$ are independently and
uniformly distributed over $10$ distinct values. Hence, a single
equality condition such as $f = 2$ has selectivity $1/10$, and the
conjunction $f = 2 \land g = 10$ has selectivity $1/10 \cdot 1/10 =
1/100$. The relation cardinalities are:
\[
\Card(U) = 10,\quad \Card(V) = 100000,\quad \Card(W) = 1000000.
\]

\paragraph{Non-optimized operator tree}

In the canonical (non-optimized) tree, the operations on $V$ and $W$
start with the Cartesian product:
\[
V \times W, \qquad
\Card(V \times W) = \Card(V) \cdot \Card(W)
= 100000 \cdot 1000000
= 10^{11}.
\]

Then the selection
\[
\sigma_{V.e = W.e \,\land\, f = 2 \,\land\, g = 10}(V \times W)
\]
is applied. We can reason about its effect as follows:

\begin{itemize}
  \item The conditions $f = 2$ and $g = 10$ refer only to $W$ and are
        independent and uniform, so together they have selectivity
        $1/100$.
        Applying them to $V \times W$ reduces the size from $10^{11}$
        to
        \[
          10^{11} \cdot \frac{1}{100} = 10^{9}.
        \]
  \item The remaining condition $V.e = W.e$ is an equality join on a
        uniformly distributed key. With uniformity, the probability
        that $V.e$ and $W.e$ match for a random pair is approximately
        $1 / \Card(W)$, so we obtain
        \[
          10^{9} \cdot \frac{1}{1000000} = 1000
        \]
        tuples after this selection.
\end{itemize}

The subsequent projection $\pi_{V.c, V.d, W.e, W.f, W.g}$ does not
change the number of tuples, so the intermediate result before joining
with $U$ still has about $1000$ tuples. The join with $U$ and the
selection on $a$ produce a very small final result compared to the
sizes above.

The \emph{dominant} intermediate result in the non-optimized tree is
therefore the Cartesian product $V \times W$ with
\[
\Card_{\max}^{\text{(non-opt)}} \approx 10^{11} \text{ tuples.}
\]

\paragraph{Optimized operator tree}

In the optimized tree from the previous subtask, selections and
projections are pushed down:

\begin{itemize}
  \item On $U$: first $\pi_{a,b,c}(U)$ keeps $10$ tuples, then
        $\sigma_{a \text{ LIKE 'Ben'}}$ selects one out of $10$ values
        of $a$:
        \[
          \Card\bigl(\sigma_{a \text{ LIKE 'Ben'}}(\pi_{a,b,c}(U))\bigr)
          = 10 \cdot \frac{1}{10} = 1.
        \]
  \item On $W$: first $\pi_{e,f,g}(W)$ keeps $1000000$ tuples, then
        $\sigma_{f = 2 \land g = 10}$ has selectivity $1/100$:
        \[
          \Card\bigl(\sigma_{f = 2 \land g = 10}(\pi_{e,f,g}(W))\bigr)
          = 1000000 \cdot \frac{1}{100} = 10000.
        \]
  \item On $V$: $\pi_{c,e}(V)$ keeps all $100000$ tuples (only the
        attributes change, not the number of rows).
\end{itemize}

We then join the reduced $V$ and $W$:
\[
\pi_{c,e}(V) \Join_{V.e = W.e}
\sigma_{f = 2 \land g = 10}(\pi_{e,f,g}(W)).
\]

Under the uniform foreign-key assumption, the fraction of $W$'s key
values that survive the selection is
\[
\frac{\Card(\sigma_{f = 2 \land g = 10}(W))}{\Card(W)}
=
\frac{10000}{1000000}
=
\frac{1}{100}.
\]
Each tuple in $V$ therefore matches with probability $1/100$, so the
join result has expected size
\[
\Card(V \Join W')
\approx \Card(V) \cdot \frac{1}{100}
= 100000 \cdot \frac{1}{100}
= 1000,
\]
where $W' = \sigma_{f = 2 \land g = 10}(W)$.

Joining this intermediate result (about $1000$ tuples) with
$\sigma_{a \text{ LIKE 'Ben'}}(\pi_{a,b,c}(U))$ (one tuple) on $c$
yields a very small final result. The largest intermediate results in
the optimized plan are thus the base relation $W$ with $10^6$ tuples
and the filtered subset of $W$ with only
\[
\Card\bigl(\sigma_{f = 2 \land g = 10}(W)\bigr) = 10000
\]
tuples before the join.

Compared to the non-optimized tree, the \emph{largest} intermediate
result in the optimized tree is:
\[
\Card_{\max}^{\text{(opt)}} \approx 10000 \text{ tuples (on the
filtered $W$),}
\]
instead of the huge Cartesian product with
\(\Card_{\max}^{\text{(non-opt)}} \approx 10^{11}\) tuples. This shows
why pushing selections down and avoiding Cartesian products is crucial
for query performance.
